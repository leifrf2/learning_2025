"""
Define a class which captures customerâ€™s revenue (direct and from referral) and 
returns TopK revenue generating customers. 
The class interface is defined as follows:

Insert(revenue):
A new customer generates revenue and returns the ID of the new customer. 
customerID is an auto-increment ID. The first insert is 0, the second is 1, and so on.

Insert(revenue, referrerID):
The existing customer with the ID referrerID refers a new customer, generates revenue, 
and returns the ID of the new customer. 
In this case, it is considered that the referrer also generates revenue. 

For example, the revenue generated by customer 0 before was 20, 
and he referred the new customer, generating 40 revenue, and the revenue generated by customer 0 became 60.

GetKLowestRevenue(k, targetRevenue):
Given k and revenue, it is required to return the customer ID corresponding to the
k smallest revenues that are greater than the given revenue.
"""

# start 4:50

from typing import Dict, Optional
from sortedcontainers import SortedList

class RevenueManager:

    """
    okay, how can we improve this?
    
    what do we know:
        - value is always increasing
        - an existing element may have its value changed
        - need bottom K
    
    what if we used a sortedlist (binary tree)?
        - insert is logn
        - bottom K would be log(N) + K
            (logN to find targetValue, then K to get K greater elements)

    ** so if K is closer to n than logN, this is a less efficient implementation
    """

    def __init__(self):
        # customer_id -> 
        self.revenue_map: Dict[int, int] = dict()
        self.next_customer_id: int = 0
    
    def get_next_customer_id(self):
        next_id = self.next_customer_id
        self.next_customer_id += 1
        return next_id

    # O(1)
    def insert(self, revenue: int, referrerID: Optional[int] = None) -> int:
        cust_id = self.get_next_customer_id()
        self.revenue_map[cust_id] = revenue

        if referrerID in self.revenue_map.keys():
            self.revenue_map[referrerID] += revenue
        
        return cust_id

    # n log(n)
    def getKLowestRevenue(self, k, targetRevenue):
        return [customer_id for customer_id, _ 
                in (sorted([
                        (customer_id, revenue) for (customer_id, revenue)
                        in self.revenue_map.items()
                        if revenue > targetRevenue
                    ],
                    lambda x: x[1])
                    )
                ][:k]
